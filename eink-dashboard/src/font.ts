/**
 * Bitmap font renderer for 1-bit pixel buffers.
 * Two sizes: "large" (16px tall, ~10px wide) and "small" (8px tall, ~6px wide).
 * Covers ASCII 32–126 using hardcoded pixel patterns.
 *
 * Characters are rendered as black (0) on whatever background exists.
 */

// 8x8 pixel font data — each character is 8 bytes, each byte is one row (MSB = left pixel).
// Covers ASCII 32 (space) through 126 (~). Classic CP437-style bitmap font.
export const FONT_8X8: number[][] = [
  // 32: space
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  // 33: !
  [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00],
  // 34: "
  [0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00],
  // 35: #
  [0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00],
  // 36: $
  [0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00],
  // 37: %
  [0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00],
  // 38: &
  [0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00],
  // 39: '
  [0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],
  // 40: (
  [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00],
  // 41: )
  [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00],
  // 42: *
  [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
  // 43: +
  [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00],
  // 44: ,
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30],
  // 45: -
  [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
  // 46: .
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
  // 47: /
  [0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00],
  // 48: 0
  [0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00],
  // 49: 1
  [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00],
  // 50: 2
  [0x7C, 0xC6, 0x06, 0x3C, 0x60, 0xC0, 0xFE, 0x00],
  // 51: 3
  [0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00],
  // 52: 4
  [0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x00],
  // 53: 5
  [0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00],
  // 54: 6
  [0x3C, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00],
  // 55: 7
  [0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00],
  // 56: 8
  [0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00],
  // 57: 9
  [0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00],
  // 58: :
  [0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00],
  // 59: ;
  [0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30],
  // 60: <
  [0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00],
  // 61: =
  [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00],
  // 62: >
  [0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00],
  // 63: ?
  [0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00],
  // 64: @
  [0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7E, 0x00],
  // 65: A
  [0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00],
  // 66: B
  [0xFC, 0xC6, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0x00],
  // 67: C
  [0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00],
  // 68: D
  [0xF8, 0xCC, 0xC6, 0xC6, 0xC6, 0xCC, 0xF8, 0x00],
  // 69: E
  [0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xFE, 0x00],
  // 70: F
  [0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xC0, 0x00],
  // 71: G
  [0x7C, 0xC6, 0xC0, 0xCE, 0xC6, 0xC6, 0x7E, 0x00],
  // 72: H
  [0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00],
  // 73: I
  [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00],
  // 74: J
  [0x1E, 0x06, 0x06, 0x06, 0xC6, 0xC6, 0x7C, 0x00],
  // 75: K
  [0xC6, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0xC6, 0x00],
  // 76: L
  [0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00],
  // 77: M
  [0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00],
  // 78: N
  [0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00],
  // 79: O
  [0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00],
  // 80: P
  [0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0xC0, 0x00],
  // 81: Q
  [0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06],
  // 82: R
  [0xFC, 0xC6, 0xC6, 0xFC, 0xD8, 0xCC, 0xC6, 0x00],
  // 83: S
  [0x7C, 0xC6, 0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00],
  // 84: T
  [0xFE, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
  // 85: U
  [0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00],
  // 86: V
  [0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00],
  // 87: W
  [0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00],
  // 88: X
  [0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00],
  // 89: Y
  [0xC6, 0xC6, 0x6C, 0x38, 0x18, 0x18, 0x18, 0x00],
  // 90: Z
  [0xFE, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFE, 0x00],
  // 91: [
  [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00],
  // 92: backslash
  [0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00],
  // 93: ]
  [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00],
  // 94: ^
  [0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00],
  // 95: _
  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE],
  // 96: `
  [0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00],
  // 97: a
  [0x00, 0x00, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00],
  // 98: b
  [0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xFC, 0x00],
  // 99: c
  [0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00],
  // 100: d
  [0x06, 0x06, 0x7E, 0xC6, 0xC6, 0xC6, 0x7E, 0x00],
  // 101: e
  [0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00],
  // 102: f
  [0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00],
  // 103: g
  [0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x7C],
  // 104: h
  [0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00],
  // 105: i
  [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00],
  // 106: j
  [0x06, 0x00, 0x0E, 0x06, 0x06, 0x66, 0x66, 0x3C],
  // 107: k
  [0xC0, 0xC0, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0x00],
  // 108: l
  [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
  // 109: m
  [0x00, 0x00, 0xCC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00],
  // 110: n
  [0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00],
  // 111: o
  [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00],
  // 112: p
  [0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0],
  // 113: q
  [0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x06],
  // 114: r
  [0x00, 0x00, 0xDC, 0xE6, 0xC0, 0xC0, 0xC0, 0x00],
  // 115: s
  [0x00, 0x00, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x00],
  // 116: t
  [0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00],
  // 117: u
  [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x00],
  // 118: v
  [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00],
  // 119: w
  [0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00],
  // 120: x
  [0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00],
  // 121: y
  [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C],
  // 122: z
  [0x00, 0x00, 0xFE, 0x0C, 0x38, 0x60, 0xFE, 0x00],
  // 123: {
  [0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00],
  // 124: |
  [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
  // 125: }
  [0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00],
  // 126: ~
  [0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
];

/**
 * Draw a single character from the 8x8 font onto the pixel buffer.
 * Black pixels (0) are drawn; white pixels in the glyph are left unchanged.
 */
function drawChar8(
  buf: Uint8Array,
  bufWidth: number,
  x: number,
  y: number,
  charCode: number
): void {
  const idx = charCode - 32;
  if (idx < 0 || idx >= FONT_8X8.length) return;
  const glyph = FONT_8X8[idx];
  for (let row = 0; row < 8; row++) {
    const byte = glyph[row];
    for (let col = 0; col < 8; col++) {
      if (byte & (0x80 >> col)) {
        const px = x + col;
        const py = y + row;
        if (px >= 0 && px < bufWidth && py >= 0) {
          buf[py * bufWidth + px] = 0; // black
        }
      }
    }
  }
}

/**
 * Measure the pixel width of a string at a given scale.
 */
export function measureText(text: string, scale: number): number {
  const charWidth = 8 * scale;
  const spacing = scale; // 1px spacing per scale unit
  return text.length * charWidth + Math.max(0, text.length - 1) * spacing;
}

/**
 * Draw text onto a 1-bit pixel buffer.
 * @param buf - pixel buffer (0=black, 1=white)
 * @param bufWidth - buffer width in pixels
 * @param x - starting x position
 * @param y - starting y position
 * @param text - ASCII text to render
 * @param scale - integer scale factor (1=8px, 2=16px, 3=24px tall)
 */
export function drawText(
  buf: Uint8Array,
  bufWidth: number,
  bufHeight: number,
  x: number,
  y: number,
  text: string,
  scale: number = 1
): void {
  const charWidth = 8 * scale;
  const spacing = scale;

  for (let i = 0; i < text.length; i++) {
    const cx = x + i * (charWidth + spacing);
    const code = text.charCodeAt(i);

    if (scale === 1) {
      drawChar8(buf, bufWidth, cx, y, code);
    } else {
      // Scale up: draw each pixel as a scale×scale block
      const idx = code - 32;
      if (idx < 0 || idx >= FONT_8X8.length) continue;
      const glyph = FONT_8X8[idx];
      for (let row = 0; row < 8; row++) {
        const byte = glyph[row];
        for (let col = 0; col < 8; col++) {
          if (byte & (0x80 >> col)) {
            // Draw a scale×scale block
            for (let sy = 0; sy < scale; sy++) {
              for (let sx = 0; sx < scale; sx++) {
                const px = cx + col * scale + sx;
                const py = y + row * scale + sy;
                if (px >= 0 && px < bufWidth && py >= 0 && py < bufHeight) {
                  buf[py * bufWidth + px] = 0; // black
                }
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Draw text centered horizontally within a given width.
 */
export function drawTextCentered(
  buf: Uint8Array,
  bufWidth: number,
  bufHeight: number,
  y: number,
  text: string,
  scale: number,
  regionLeft: number = 0,
  regionRight: number = bufWidth
): void {
  const textWidth = measureText(text, scale);
  const regionWidth = regionRight - regionLeft;
  const x = regionLeft + Math.max(0, Math.floor((regionWidth - textWidth) / 2));
  drawText(buf, bufWidth, bufHeight, x, y, text, scale);
}

/**
 * Word-wrap text to fit within maxWidth pixels, then draw each line.
 * Returns the Y position after the last line.
 */
export function drawTextWrapped(
  buf: Uint8Array,
  bufWidth: number,
  bufHeight: number,
  x: number,
  y: number,
  text: string,
  scale: number,
  maxWidth: number,
  lineSpacing: number = 2
): number {
  const charWidth = 8 * scale + scale;
  const maxChars = Math.floor(maxWidth / charWidth);
  const lines = wordWrap(text, maxChars);
  const lineHeight = 8 * scale + lineSpacing * scale;

  for (const line of lines) {
    drawText(buf, bufWidth, bufHeight, x, y, line, scale);
    y += lineHeight;
  }

  return y;
}

function wordWrap(text: string, maxChars: number): string[] {
  const words = text.split(" ");
  const lines: string[] = [];
  let current = "";

  for (const word of words) {
    if (current.length === 0) {
      current = word;
    } else if (current.length + 1 + word.length <= maxChars) {
      current += " " + word;
    } else {
      lines.push(current);
      current = word;
    }
  }
  if (current.length > 0) {
    lines.push(current);
  }

  return lines;
}
